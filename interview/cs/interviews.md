# 코드 의존성과 DRY 원칙
    - 어떤 스크립트는 다른 추가적인 스크립트를 필요로 하기도 한다.
    - 이 때 다른 스크립트에 의존하는 스크립트를 작성할 때 해당 스크립트에 의존성이 있다고 표현한다.
        - jQuery를 활용하는 스크립트는 의존성이 있다고 할 수 있다.
    - DRY 원칙
        - Don't Repeat Yourself의 줄임말로 소프트웨어 개발 원칙
        - 같은 작업을 수행하는 코드를 두 번 작성했다는 이를 코드 중복이라 하는데 DRY원칙은 이러한 코드 중복을 지양하자는 원칙이다.
        - 함수를 활용하는 것은 코드 재사용의 좋은 예로, 재사용 가능한 함수를 헬퍼 함수라고 한다.
        - 코드 재사용을 권장하기 위해 개발자들은 작은 스크립트를 작성하는데, 이 때문에 코드 재사용은 코드 사이에 더 많은 의존성을 만든다.

# process vs thread
    - process
        - 실행중인 프로그램
        - 디스크로부터 메모리로 적재되어 CPU의 할당을 받을 수 있다.
        - 생성될 때 각각 별도의 주소 공간에 할당되며, code, data, heap, stack 영역을 가지고 있다.
        - Multi-Process의 장점은 각 프로세스간 독립적으로 동작하기 때문에 서로 영향을 끼치지 않는다. 하지만 각각 독립된 메모리 영역을 가지고 있어 다른 프로세스와 데이터 공유 간 IPC를 해야하는 경우 오버헤드가 있으며, Context Switching에 대한 오버헤드도 존재한다.
    - thread
        - 프로세스의 실행 단위
        - 스레드는 다른 스레드와 공간, 자원을 공유한다.
        - 멀티 스레드의 장점은 전역 변수와 정적 변수에 대한 자료를 공유한다.
        - 단점은 하나의 스레드가 다른 스레드에 영향을 끼칠 수 있으며 동기화에 신경 써야한다.
    - 프로세스가 생성되면 PCB라는 프로세스 제어 블록이 생성된다.
        - 여기에는 PID, status, info가 저장되어 있으며 context switching이 발생하면 현재 작업 정보를 저장하고 다시 CPU를 할당받으면 PCB로부터 이전의 작업 정보를 불러온다.

# code, data, stack, heap
    - code
        - 프로그램의 소스 코드를 저장
    - data
        - 전역 변수, 정적 변수 저장
    - stack
        - 함수, 지역 변수 저장
    - heap
        - 동적으로 할당한 것을 저장

# interrupt
    - 주변 장치의 입출력 요구나 하드웨어 이상 현상을 CPU에게 알려주는 역할을 하는 신호
    - 프로그램을 실행하는 도중에 예기치 않은 상황이 발생한 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황을 우선 처리한 후, 실행 중이던 작업으로 복귀하여 계속 처리하는 것
    - 인터럽트에는 입출력과 같은 외부 인터럽트, 오버플로우, 0으로 나누는 상황으로 인한 내부 인터럽트가 있다.

# scheduler
    - 장기 스케쥴러
        - 메모리와 디스크 사이의 스케쥴링을 담당
        - 프로세스에 메모리를 할당한다.
        - 프로세스에 메모리가 할당되면, 프로세스는 ready 상태가 된다.
    - 중기 스케쥴러
        - 여유 공간을 마련하기 위해 프로세스를 메모리에서 디스크로 스와핑한다.
        - 스와핑이 되면 해당 프로세스는 suspended 상태가 된다.
    - 단기 스케쥴러
        - CPU와 메모리 사이의 스케쥴링 담당
        - 프로세스의 CPU를 할당
        - 프로세스에 CPU가 할당되면, 프로세스는 running 상태가 된다.

# CPU 스케쥴러 ( 단기 스케쥴러 )
    - FCFS
        - 먼저 온 순서대로 처리하는 스케쥴링 방식
        - 비선점형 스케쥴링
        - 실행 시간이 긴 프로세스 때문에 뒤의 프로세스들이 밀리는 컨베이 효과가 발생하는 문제점이 있음
    - SJF
        - 짧은 작업 시간을 가진 프로세스를 먼저 처리하는 스케쥴링 방식
        - 비선점형 스케쥴링이며 작업 시간이 긴 프로세스가 계속 밀리는 starvation 효과가 발생하는 문제점이 있음
    - 우선순위 스케쥴링
        - 우선순위가 가장 높은 프로세스를 먼저 처리하는 스케쥴링 방식
        - 선점형 스케쥴링과 비선점형 스케쥴링 방식이 있다.
        - 선점형 스케쥴링
            - 더 높은 우선 순위의 프로세스가 도착하면, 해당 프로세스가 CPU를 선점하는 것
        - 비선점형 스케쥴링
            - 더 높은 우선 순위의 프로세스가 도착하면, queue에 맨 앞에 위치하는 것
        - 우선 순위가 낮은 것들이 밀리는 starvation 효과가 발생하는 문제점이 있으며, aging을 적용하여 이를 해결할 수 있다.
    - RR
        - 현대적인 CPU 스케쥴링 방식으로 각 프로세스는 동일한 크기의 할당 시간인 time quantum을 갖는다.
        - 이 때 time quantum이 너무 커지면 FCFS와 같아져 컨베이 효과가 발생하고 너무 작아지면 잦은 context switch로 오버헤드가 발생한다.
        - 적당한 time quantum을 설정하는 것이 중요함

# cache
    - CPU와 메모리 사이의 속도 차이를 해결하기 위한 방법
    - cache 적중률( hit )을 높이기 위해 지역성의 원리를 기반한다.
    - 시간 지역성
        - 참조한 주소는 다시 참조할 확률이 높다는 것
    - 공간 지역성
        - 최근 참조한 주소의 주변 주소를 참조할 확률이 높다는 것
    - cache line은 캐시에 데이터를 저장할 때 자료구조를 활용해 묶어서 저장하는 것을 말하며 캐시에 저장하는 데이터에 데이터의 메모리 주소를 함께 저장하면서 빠르게 원하는 정보를 찾을 수 있다.

# semaphore & mutex
    - semaphore
        - 세마포어는 공유 자원을 여러 프로세스가 접근하는 것을 막는 것
        - 카운팅 세마포어의 경우 가용한 개수를 가진 자원에 대한 접근 제어용으로 사용되며, 자원을 사용하면 세마포어가 감소하고 방출하면 세마포어가 증가한다.
    - mutex
        - 뮤텍스는 공유 자원을 여러 스레드가 접근하는 것을 막는다.
        - 뮤텍스는 상태가 0, 1로 이진 세마포어라고 부르기도 함

# paging & segmenation
    - paging
        - 고정 분할 방식
        - 물리 주소 공간을 같은 크기로 나누어 사용
        - 내부 단편화 발생
    - segmenation
        - 가변 분할 방식
        - 각 프로세스는 여러 세그먼트들로 나뉜다.
        - 외부 단편화 발생