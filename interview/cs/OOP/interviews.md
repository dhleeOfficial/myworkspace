# OOP
    - Object Oriented Programming
    - 컴퓨터 프로그램을 객체들의 모임으로 파악하고자 하는 프로그래밍 패러다임 중에 하나
    - 각 객체들은 서로 메시지를 주고 받을 수 있으며 데이터를 처리할 수 있다.
    - 장점
        - 프로그램을 유연하고 변경이 용이하게 만듦
        - 프로그램의 개발과 보수를 간편하게 만듦
        - 직관적인 코드 분석
    - 강한 응집력과 약한 결합력을 지향한다.
    - 기본 구성 요소
        - 클래스
            - 같은 종류의 집단에 속하는 속성과 행위를 정의한 것
            - 다른 클래스와 독립적으로 디자인해야함
        - 객체
            - 클래스의 인스턴스
            - 상위 클래스의 속성을 가지고 있으면서 개별저인 특성과 행위 또한 가지고 있다.
        - 메소드
            - 클래스로부터 생성된 객체를 사용하는 방법
            - 객체의 속성을 조작하는데 사용됨
# OOP의 특징
    - 추상화 ( Abstraction )
        - 객체들이 가진 공통의 특성들을 파악하고 불필요한 특성들을 제거하는 과정
        - 객체들이 가진 동작들을 기준으로 이용자들이 동작만 쉽게 구동할 수 있도록 한다.
        - 속성 위주가 아닌 동작 위주로 정의하는 작업
    - 캡슐화 ( Capulation )
        - 데이터를 은닉하고 데이터의 기능을 노출시키지 않음을 의미
        - 객체의 데이터를 외부에서 직접 접근하지 못하게 막고, 함수를 통해서만 조작이 가능하게 한다.
    - 상속
        - 하나의 클래스가 가진 특징을 그대로 다른 클래스에게 물려줄 수 있는 특성
    - 다형성
        - 하나의 타입에 여러 객체를 대입할 수 있는 성질
        - 다형성을 구현하는 방법
            - Overloading
                - 매개변수만 다른 여러 개의 메소드를 정의할 수 있다.
                - 여러 종류의 타입을 받아들여 결국엔 같은 기능을 하도록 만들기 위한 작업
                - 보통 생성자 오버로딩을 많이 사용한다.
            - Overriding
                - 상위 클래스의 메소드를 하위 클래스에서 재정의하는 것을 말한다.

# SOLID principles
    - SRP ( Single Responsibility Principle : 단일 책임 원칙 )
        - 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는데 집중되어야 한다는 원칙
        - 이는 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
    - OCP ( Open Close Principle : 개방 폐쇄 원칙 )
        - 소프트웨어의 구성요소는 확장에는 열려있고, 변경에는 닫혀있어야 한다.
        - 변경을 위한 비용은 가능한 줄이고 확장을 위한 비용은 가능한 극대화해야한다는 의미로, 요구 사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 말아야하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야한다는 뜻
    - LSP ( The Liskov Substitution Principle : 리스코브 치환의 법칙 )
        - 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다는 원칙
        - 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다.
    - ISP ( Interface Segregatoin Principle : 인터페이스 분리의 법칙 )
        - 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리
        - 하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다.
    - DIP ( Dependency Inversion Principle : 의존성 역전의 원칙 )
        - 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것
        - 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺으라는 것

# 절차지향 vs 객체지향
    - 절차지향
        - 물이 위에서 아래로 흐르는 것처럼 순차적인 처리를 중요시하는 프로그래밍 기법
        - 컴퓨터의 처리구조와 유사해 실행속도가 빠르다.
        - 코드의 순서가 바뀌면 동일한 결과를 보장하기 어렵다.
    - 객체지향
        - 실제 세계의 사물들을 객체로 모델링하여 개발을 진행하는 프로그래밍 기법
        - 캡슐화, 상속, 다형성 등과 같은 기법을 이용할 수 있다.

# 메모리 구조
    - Code
        - 실행할 프로그램의 코드가 저장되는 영역으로 사용자가 프로그램 실행 명령을 내리면 OS가 HDD에서 실행 코드를 메모리로 올리게 되고, CPU는 코드 영역에 저장된 명령어를 하나씩 처리하게 된다.
    - Data
        - 프로그램의 전역 변수와 정적 변수가 저장되는 영역
        - 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료하면 소멸한다.
    - Heap
        - 프로그래머가 직접 관리할 수 있는 메모리 영역으로 이 공간에 메모리를 할당하는 것을 동적 할당이라고 한다.
        - Java에서는 가비지 컬렉터가 자동으로 해제해준다.
        - Heap 영역은 Stack 영역과 달리 낮은 주소에서 높은 주소로 메모리가 할당된다.
    - Stack
        - 함수의 호출과 함께 할당되며 지역 변수와 매개 변수가 저장되는 영역
        - 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임이라고 하며 스택 영역은 함수의 호출이 완료되면 소멸한다.
        - 스택 영역은 높은 주소에서 낮은 주소로 메모리가 할당됨

# Parameter와 Argument의 차이
    - Parameter
        - 함수를 선언할 때 사용된 변수
    - Argument
        - 함수가 호출되었을 때 함수의 파라미터로 전달된 실제 값

# Call by value vs Call by reference
    - Call By Value
        - 인자로 받은 값을 복사하여 처리하는 방식
        - Call by value에 의해 넘어온 값을 증가시켜도 원래의 값은 보존됨
        - 값을 복사하여 넘기기 때문에 메모리 사용량이 늘어난다.
    - Call by reference
        - 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 주는 방식
        - 값을 복사하지 않고 직접 참조하기 때문에 속도가 빠르다.
        - 원래의 값에 영향을 주는 리스크가 존재