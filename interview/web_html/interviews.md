# 브라우저의 동작 원리
    - 사용자가 참조하고자 하는 웹페이지를 서버에 요청하고 서버의 응답을 받아 브라우저에 표시하는 것
    - 서버로부터 HTML, CSS, JavaScript, image 파일 등을 응답받음
    - HTML, CSS 파일은 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱되어 DOM, CSSOM 트리로 변환되고 렌더링 트리로 결합
    - 자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리!
        - HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘김
        - 자바스크립트 엔진은 script 태그 내의 자바스크립트 코드 또는 script 태그의 src 어트리뷰터에 정의된 자바스크립트 파일을 로드하고 파싱하여 실행
        - 자바스크립트의 실행이 완료도면 다시 HTML 파서로 제어 권한을 넘겨 DOM 생성 재개
    - 브라우저는 동기적으로 HTML, CSS, Javascript를 처리하기 때문에!!
        - script 태그의 위치에 따라 블로킹이 발생하여 DOM의 생성이 지연될 수 있음
        - 따라서 script 태그의 위치는 중요한 의미를 가짐
            - body 요소의 가장 아래에 자바스크립트를 위치시킴
                - HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축됨
                - DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러발생할 수 있음
    - 브라우저의 기본적인 역할은 HTML, CSS 명세에 따라 HTML 파일을 해석하여 표시
    - 브라우저 구성 요소
        - 사용자 인터페이스 (UI)
        - 브라우저 엔진
            - Chrome - blink
            - Safari - webkit
            - firefox - Gecko
        - 렌더링 엔진
        - 통신
        - UI 백엔드
        - 자바스크립트 해석기
        - 자료 저장소
        - etc
    - 렌더링 엔진은 HTML 문서를 파싱해서 DOM 트리를 구축
    - CSS 마크업을 파싱해서 앞서 구축한 DOM 트리와 함께 렌더링 트리를 만듦
        - 렌더링 트리는 화면에 보여줄 것들만 가지고 있는 트리로 구축이 되면 순차적으로 화면에 배치
    - 부모에서 자식 순서로 배치가 진행되며, 완료되면 그리기를 시작한다.

# script 태그의 async와 defer 속성
    - 일반적으로 <script> 요소를 통해 HTML 파일에 자바스크립트 파일을 포함
    - <script> 요소를 이용해 inline으로 자바스크립트를 작성하거나 src 속성에 자바스크립트의 위치를 지정해서 외부 스크립트를 불러올 수 있음!
    - 일반적으로 <script>는 HTML의 <head> 요소 안에 작성
        - 이곳에 작성하면 css 등 외부로부터 불러오는 리소스 파일을 한군데에서 관리할 수 있는 장점이 있음
            - ex)
                <!doctype html>
                <html>
                    <title>TITLE</title>
                    <link href="stylesheet.css" rel='stylesheet" type="text/css">
                    <script src="script.js"></script>
                    <body>
                        ...
                    </body>
                </html>
            - 브라우저가 HTML 렌더링에 영향을 줌
            - HTML을 파싱하는 동안 브라우저는 <script>를 만날 때마다 파싱을 중지하고 스크립를 로드하고 실행하게 됨
            - 이 과정에서 외부 스크립트를 로드하는 네트워크 왕복 시간, 자바스크립트를 실행하는 시간만큼 렌더링이 지연됨
    - 그래서 최근 웹에서는 일반적으로 <script>를 <body>의 맨 아래에 삽입함
        - body의 내용이 렌더링 된 이후에 script를 만나 로드하고 실행하기 때문에 렌더링 타이밍이 빨라진다.
        - 또한 스크립트가 렌더링 된 DOM에 접근할 수 있는 장점이 있음
    - defer
        - <script>는 다운로드와 실행이 순차적으로 진행되는 것과 달리 defer 속성을 가진 스크립트는 <script defer>를 만났을 때 다운로드를 시작하지만, HTML 파싱을 막지 않고 </html>을 만났을 때 실행함
        - 주로 DOM을 조작하는 내용이 포함되는 것이 좋음
        - 하지만 일부 브라우저에서는 defer 속성을 지원하지 않음을 주의
    - async
        - <script>, <script defer>와 마찬가지로 브라우저가 해당 요소를 만났을 때 외부 스크립트 다운로드 시작
        - defer와 마찬가지로 다운로드 중에 HTML 파싱을 막지 않지만 다운로드가 완료되면 즉시 실행하고, 실행하는 동안 브라우저는 HTML 파싱을 멈춤
        - 주로 DOM을 조작하지 않으며, 앞뒤에 로드되고 실행될 스크립트와 의존성이 없는 코드만 포함하는 것이 좋음

# Web protocol
    - 웹에서 쓰이는 통신 규약
    - Http 통신
        - 웹 프로토콜 중 하나로 Http가 가장 많이 쓰이며 HyperText Transfer Protocol의 약자
        - 인터넷에서 데이터를 주고 받을 수 있는 통신 규약이며, 요청과 응답으로 구성됨
    - Http 1.1과 2.0의 차이
        - 속도 차이!
            - 2.0은 헤더를 압축해서 보내기도 하고, 한번의 연결로 동시에 여러 메시지를 주고 받을 수 있다.
# HTTP와 HTTPS 통신 방식 차이
    - 결정적 차이는 보안!
    - Http 방식 vs Https
        - Http 방식은 네트워크 상에서 정보를 누군가가 마음대로 열람, 수정 가능
        - Http 방식이 Https 방식보다 빠름
        - Http 방식은 민감한 정보를 다룰 때 항상 변조, 해킹 가능성을 염두해야한다.
        - 설치 및 인증서를 유지하는데 추가적인 비용이 발생

# 함수형 프로그래밍
    - 설명
        - 순수함수와 보조함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하고, 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임
    - 순수함수란?
        - 같은 입력이 주어지면, 같은 출력을 반환하고 사이드 이펙트가 없는 함수
        - 결국, 함수형 프로그래밍은 순수함수를 통해 사이드이펙트를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 방법
    - OOP와 차이점
        - OOP는 객체 안에 상태를 저장하고, 이 상태를 이용하여 메소드를 추가하고, 상태 변화를 설정하고 조정하기 위해 다양한 기능을 사용하지만, 함수형 프로그래밍은 상태를 저장하지 않고 없애는데 주력한다.

# CORS
    - Cross Origin Resource Sharing
    - 다른 도메인에서 리소스 요청 시, cross-origin HTTP에 의해 요청을 하는데, 대부분의 브라우저는 보안 상의 이유로 이 요청을 제한함. (Same Origin Policy)
        - 요청을 보내기 위해서는 요청을 보내는 대상과 프로토콜과 포트가 같아야 한다.
        - 같은 Origin에서만 리소스를 공유할 수 있다!
        - 하지만, 웹이라는 오픈스페이스 환경에서 다른 출처에 있는 리소스를 가져와 사용하는 일은 굉장히 흔해 무작정 막을 수 없다!
        - 그래서 몇 가지 예외 조항을 두고, 이 조항에 해당하는 리소스 요청은 출처가 다르더라도 허용하기로함!
    - 사실 출처가 다른 두 개의 어플리케이션이 마음대로 소통할 수 있는 환경은 위험함
        - 웹에서 돌아가는 클라이언트 어플리케이션은 사용자의 공격에 매우 취약함
            - 브라우저 개발자 도구만 열어도 모두 확인이 가능
            - 자바스크립트 소스 코드 난독화? -> 말그대로 난독화일뿐
        - 이러한 상황에서 다른 출처의 어플리케이션이 서로 통신하는 것에 대해 제약이 없다면?
            - CSRF / XSS와 같은 방법으로 어플리케이션에서 실행된 것처럼 꾸며 사용자의 정보를 탈취할 수 있다.
    - 같은 출처와 다른 출처의 구분
        - 출처를 비교하는 로직은 서버 스펙이 아니라 브라우저 스펙!
            - CORS 정책을 위반하는 리소스 요청을 하더라도 해당 서버가 같은 출처에서 보낸 요청만 받겠다는 로직을 가지고 있지 않다면? 서버는 정상 응답을 함
            - 하지만 브라우저에서 이 응답을 분석해 버릴 수 있음
            - 브라우저를 통하지 않고 서버 간 통신을 할 때는 이 정책이 적용되지 않음 
    - 동작 방식
        - 기본적으로 웹 클라이언트 어플리케이션이 다른 출처의 리소스를 요청할 때는 HTTP 프로토콜을 사용하여 요청하며, 이 때 요청 헤더에 Origin이라는 필드에 요청을 보내는 출처를 담아 보낸다.
        - 이 후 서버가 이 요청에 대한 응답을 할 때, 응답 헤더의 Acess-Control-Allow-Origin 이라는 값에 “이 리소스를 접근하는 것이 허용된 출처”를 내려준다.
        - 이 후 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin과 서버가 보내준 응답의 Acess-Control-Allow-Origin을 비교하여 이 응답이 유효한 응답인지 아닌지를 결정한다
    - 기본적인 흐름은 간단하지만 CORS가 동작하는 방식은 세 가지 시나리오에 따라 변경 가능
        - Preflight request
            - 일반적으로 웹 어플리케이션을 개발할 때 가장 많이 마주치는 시나리오
            - 이 경우, 브라우저는 요청을 한번에 보내지 않고, 예비 요청과 본 요청으로 나누어서 서버로 전송함
            - 예비 요청을 Preflight라고 부르며, HTTP 메소드 중 OPTIONS 메소드가 사용된다.
            - 예비 요청의 역할은 본 요청을 보내기 전에 브라우저 스스로 이 요청을 보내는 것이 안전한지 확인하는 것
        - Simple request
            - preflight request를 보내지 않고 바로 서버에게 본 요청부터 함
            - 서버가 이에 대한 응답 헤더에 Access-Control-Allow-Origin과 같은 값을 보내주면 브라우저가 그때 CORS 정책 위반 여부를 검사하는 방식
            - 하지만 이 요청 방식은 특정 조건을 만족하는 경우에만 예비 요청을 생략할 수 있음
                - 요청 메소드는 GET, HEAD, POST 중 하나여야만 한다
        - Credentialed request
    - CORS 정책 위반 해결 방법
        - Access-Control-Allow-Origin 값 설정하기
        - webpack-dev-server로 프록싱하기

# Cross-Browsing
    - W3C에서 채택된 웹 표준에 따라 서로 다른 OS 또는 플랫폼에 따라 달리 구현되는 기술을 비슷하게 만듦과 동시에 어느 한쪽에 최적화되어 치우치지 않도록 공통 요소를 사용하여 웹 페이지를 제작하는 기법
    - 지원할 수 없는 다른 웹 브라우저를 위한 장치를 구현하여 모든 웹 브라우저 사용자가 방문했을 때 정보로서의 소외감을 느끼지 않도록 하는 방법론적 가이드를 의미
    - 브라우저별 렌더링 엔진이 어떠한 상황 속에서도 문제없이 동등하게 동작하는 것을 목표로함
        - 크로스 브라우징은 동일성을 의미하지 않는다.
        - 동등한 수준의 정보, 기능에 접근이 목표
    - 프론트엔드 개발자가 세울 수 있는 여러가지 전략 중 Feature detection( 기능 탐지 )을 사용해서 해당 기능이 해당 브라우저에 있는지를 확인하는 방법을 사용할 수도 있다.
    - 크로스 브라우징 대응 방법
        - CanIUse에서 사용하려는 CSS 프로퍼티가 어느 브라우저의 어느 버전까지 지원되는지 궁금할 때 확인 가능 / JS도 물론 확인 가능
        - 라이브러리 사용하기
            - jQuery
                - 자바스크립트 이벤트에 대해 크로스 브라우징 기능을 제공함
            - polyfil
            - reset.css or normalize.css 사용
            - prefix 사용
            - hack
            - IE 용 주석을 이용한 방법 등등

# polyfil

# SSR vs CSR
    - SSR
        - 전통적인 웹 방식을 의미하며 페이지가 새로고침 될 때마다 서버로부터 리소스를 전달받아 화면에 렌더링하는 방식
        - 하지만 React, Vue 등의 라이브러리가 등장하면서 훨씬 더 좋은 성능의 SPA 방식의 개발환경을 선호하기 시작!
        - TTV 이후, js 로직을 서버에서 받아온 뒤부터 TTI가 가능
    - CSR
        - 서버는 단지 JSON 파일을 보내주는 역할만 할 뿐이며, HTML을 그리는 역할을 클라이언트에서 수행
        - 자바스크립트가 모든 동작을 수행한 후 화면에 내용이 나타나므로 초기 구동속도는 SSR에 비해 느리다.
        - 또한 SEO를 할 수 없고 보안적으로 취약함
        - TTV와 TTI가 같은 시점에 이루어짐
    - SSG ( Static Site Generation )
        - React + Gatsby
            - 미리 정적인 HTML파일들을 만들어 놓을 수 있음
    - SSR과 CSR을 적절하게 섞어 사용하자
        - 첫번째 페이지 로딩에서는 SSR 사용하고 그 후에 모든 페이지 로드에는 CSR을 사용하는 방법을 많이 사용함
        - React에서는 Next.js, GatsbyJS / Vue에서는 Nuxt.js 등의 라이브러리가 SPA에서 SEO를 할 수 있도록 도와줌
            - Next.js의 경우, 전통적인 SSR이 아닌 SPA에서 SEO에 유리하기 위한 SSR을 도입하고, 그 이외에도 개발자들이 직접 Node에서 환경설정을 하지 않고도, 익숙한 툴을 가지고 설정을 할 수 있게 지원해준다.
            - 또는 CSR에서 메타 태그를 정의해주는 라이브러리를 사용하는 것도 방법!
                - react-helmet
                    - 동적으로 SEO에 필요한 메타태그들을 쉽게 변경할 수 있도록 도와주며, JSX 또는 TSX 내부에서 메타태그를 관리할 수 있다.

# MPA vs SPA
    - MPA (Multiple Page Application)
        - 사용자가 페이지를 요청할 때마다, 웹 서버가 요청한 UI와 필요한 데이터를 HTML로 파싱해서 보여주는 방식의 웹 어플리케이션
        - 사용자가 아주 사소한 요청을 해주어도 매번 전체 페이지를 렌더링해주어야 한다.
        - 장점
            - SEO 관점에서 유리함
            - MPA는 완성된 형태의 HTML 파일을 서버에서 전달받기에 검색엔진이 페이지를 크롤링하기에 적합
        - 단점
            - 매번 페이지 전체를 새로 불러와서 렌더링 해야하기 때문에 화면이 깜빡이는 등 성능상의 이슈
    - SPA (Single Page Application)
        - 하나의 HTML 파일을 기반으로 자바스크립트를 이용해 동적으로 화면의 컨텐츠를 바꾸는 방식의 웹 어플리케이션
        - 처음 한번만 정적 리소스를 다운받고, 그 이후에는 새로운 요청이 들어왔을 때 필요한 데이터만 부분적으로 바꾸어줌
        - 장점
            - 사용자 경험 측면에서 좋으며, 성능이 좋다.
            - 서버 없이도 개발 가능하며 디버깅이 상대적으로 쉽다
        - 단점
            - 초기에 웹 어플리케이션에 필요한 모든 정적 리소스를 다 받아야하기 때문에 초기 구동속도가 느리다.
            - SEO 관점에서 불리함

# Cookie / Session Storage / Local Storage
    - 모두 브라우저에서 데이터 저장소의 역할을 담당
    - Cookie
        - 클라이언트 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일
        - document.cookie하면 현재 쿠키 정보가 나옴
        - 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지됨
        - 쿠키는 클라이언트의 상태 정보를 저장했다가 참조함
        - 클라이언트에 300개까지 쿠키 저장 가능 / 하나의 도메인당 20개의 값만 가질 수 있음, 하나의 쿠키값은 4kb까지 저장
        - Response header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있음
        - 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시 Request Header에 넣어서 자동으로 서버에 전송
       - 쿠키에 대한 정보가 계속적으로 서버 요청때 포함되므로 부담
    - Web storage
        - 웹 스토리지는 서버에 클라이언트 데이터를 저장하지 않음
            - 로컬 스토리지
                - 브라우저에 정보가 계속해서 남아있다.
            - 세션 스토리지
                - 해당 세션이 끝나고 나면, 즉 브라우저가 닫히면 데이터가 사라짐
        - 웹 스토리지는 데스크탑 기준 5~10MB의 저장 공간을 가지고 있어 쿠키에 비해 훨씬 저장공간이 큼 ( 모바일은 2.5MB )
            - 이것도 부족하다면 50MB를 기본적으로 저장할 수 있는 IndexedDB를 쓰자.

# Progressive Rendering
    - 서버에서 일부를 순차적으로 렌더링하면서 전체 페이지가 렌더링될 때까지 기다리지 않고 웹 페이지를 클라이언트에 스트리밍하는 기술
    - 인터넷 속도가 느리거나 불안정한 모바일 환경이 아직 남아있기 때문에 이럴 때 유용하게 사용함
    - 절차
        - 브라우저가 서버에 HTML을 요청!
        - 서버는 API 요청을 수행하고 서버에서 중요한 컨텐츠를 먼저 렌더링하여 브라우저로 스트리밍
        - 브라우저는 HTML 청크를 받아서 화면에 렌더링한다.
        - 서버는 중요 컨텐츠를 렌더링한 후 중요하지 않은 컨텐츠를 렌더링하고 이를 클라이언트로 스트리밍한다.
        - 브라우저는 나중에 중요하지 않은 컨텐츠를 받아서 렌더링
        - 전체 페이지가 로드되면 브라우저는 일반적으로 이벤트 핸들러 및 대화식 동작을 연결하는 DOM 요소에 대한 상호작용을 수화함
    - 관련 기술
        - 이미지 지연 로딩
            - 페이지의 이미지를 한꺼번에 로딩하지 않는다.
        - 보이는 컨텐츠의 우선순위 설정
            - 가능한 한 빨리 표시하기 위해 사용자 브라우저에서 렌더링될 페이지에 필요한 최소한의 CSS/Scripts/Contents만 포함하면 deferred 스크립트를 사용하거나 DOMContentLoaded / load 이벤트를 사용하여 다른 리소스와 내용을 로드할 수 있음

# <section>과 <article>의 차이
    - <section>
        - 보통 비슷한 특성의 컨텐츠를 담는 구역을 설정할 때 사용
    - <article>
        - 관련성이 없고 독립적인 내용들을 담을 때 사용
        - 예를 들어, <section> 안에서 서로 다른 기사들을 나열해야 할 때 사용함

# 여러 언어로 되어 있는 컨텐츠의 페이지를 어떻게 제공?
    - Http 요청을 서버에 보내면, 대게 요청하는 유저 에이전트가 Accept-Language 헤더와 같은 기본 언어 설정에 대한 정보를 보냄
    - 그 다음 서버는 이 정보를 사용하여 해당 언어가 제공 가능한 경우, 해당 언어 버전의 문서를 반환할 수 있다.
    - 반환된 HTML 문서는 <html lang="en">...</html>과 같이 <html> 태그에 lang 속성을 선언해야함

# img 태그에 srcset 속성을 사용하는 이유?
    - 기기의 디스플레이 너비에 따라 다른 이미지를 사용자에게 제공하고자 할 떄 사용함
    - ex> <img srcset="small.jpg 500w, medium.jpg 1000w, large.jpg 2000w" src="..." alt="..">
        - 첫번째 값은 이미지 이름 / 두번째 값은 픽셀 단위의 이미지 너비
        - 320px 너비의 경우,
            - 500 / 320 = 1.5625
            - 1000 / 320 = 3.125
            - 2000 / 320 = 6.25
        - 브라우저는 최소값에서 가장 위로 가까운 해상도를 사용
            - 해상도가 2x인 경우, 비율 값이 2에 가까운 1000w을 선택하게 됨
    
# 웹 페이지 최적화
    - 웹 브라우저가 하는 일 ( DOM, CSSOM을 만들고 렌더 트리로 결합하고 등등)을 구글에서는 Critical Rendering Path(CRP : 주요 렌더링 경로) 라고 부른다.
    - 사이트 최적화를 하는 방법 중 하나는 이 CRP를 간결하게 하는 것!
    - 방법
        - HTTP 요청 줄이기
        - CSS 스프라이트 사용하기
            - 여러 개의 이미지를 하나로 모아 이미지 파일의 갯수를 줄이는 방법
        - CDN (Content Delivery Network) 사용
            - 사용자 응답시간의 대부분이 구성 요소를 다운로드 받는데 사용된다.
            - CDN은 사용자에게 보다 효율적으로 컨텐츠를 제공하기 위해 여러 지역에 걸쳐 분산된 웹서버의 집합체로 사용자가 요청을 했을 때 고객의 네트워크에서 가장 가까운 서버를 축정하여 선택하기 때문에 가장 빠른 응답시간의 서버가 선택된다.
        - 캐시 만료일 설정
            - 설정하는 이유는 웹 페이지의 구성 요소인 HTML, CSS, JS, 이미지 등의 파일 등을 사용자 컴퓨터의 캐시에 저장해두고 재사용하기 위해서
            - 하지만 모든 구성 요소에 만료 날짜를 설정하는 것이 아니라 만료 날짜 동안 수정되지 않아도 문제가 되지 않을 요소들에게만 적용해야 한다.
        - Gzip
            - 압축을 통해서 파일 크기를 줄여 응답 시간을 줄일 수 있다.
            - 브라우저에서 사용되는 인코딩 종류는 Accept-Encoding이라는 Request Header의 attribute를 통해 서버쪽에 알려지며 서버쪽에서는 이 Accept-Encoding의 값을 보고 브라우저에서 decoding이 가능한 압축 파일을 보내게 된다.
            - Gzip은 파일의 압축에 사용되는 응용 소프트웨어이며 대부분의 브라우저에서 지원되기 떄문에 가장 대중적이며 효과적인 압축 방법
        - CSS는 최상단에!
            - CSSOM이 만들어지지 않으면 렌더링을 진행할 수 없다.
            - 따라서 브라우저가 빠르게 CSSOM을 빌드할 수 있도록, CSS는 <head> 바로 아래에 작성한다.
                <head>
                    <link href="style.css" rel="stylesheet">
                </head>
        - 자바스크립트 최적화
            - 자바스크립트는 DOM을 조작할 수 있기에 HTML 파싱을 막는다.
            - 즉, HTML을 읽다가 <script> 태그를 만나면 그 즉시 파싱은 중단되며, 이전까지 생성된 DOM만 다룰 수 있다.
            - 하지만 async나 defer 속성을 명시하면 파싱을 멈추지 않고 그대로 진행시킬 수 있다.
                - async
                    - HTML 파싱 중에 파일을 다운로드하고 다운로드가 완료되면 HTML 파서를 일시 중지하여 실행한다.
                    - 여러 외부 스크립트에 사용했을 때 순서를 보장하지않아 DOM 제어에 어려움이 있을 수 있으니 다른 스크립트에 의존하지 않는 경우 사용해라
                - defer
                    - defer는 HTML 파싱 중에 파일을 다운로드하고 파싱이 완료된 후, DOMContentLoaded 이벤트 이전에 실행됨
                    - DOM을 직접적으로 제어하는 코드가 있다면 defer로 실행
            - async나 defer는 브라우저별로 한계가 있음
        - 애니메이션 최적화
            - 가능한 자바스크립트보다 CSS로 처리하는 것이 좋다.
        - Javascript and CSS 파일을 외부로 분리하기
            - js와 css 파일을 문서 내에 배치하는 것보다 외부로 분리하여 link, script 태그로 불러오는 방식을 사용하는 방법으로 응답시간을 줄일 수 있다.
            - 브라우저에 의해 캐시에 저장된 js와 css 파일은 재사용되어 사용되기 때문이다!
        - Javascript and CSS 통합하기
            - 외부로 분리한 파일들을 최대한 통합하여 파일 갯수를 줄이는 것 또한 중요하다
            - 아무리 작은 파일이라도 사용자의 컴퓨터로 가져오기 위해서는 요청을 해야하고 요청이 많아지면 응답 시간 또한 늘어나기 때문에
        - DNS 서버 조회 줄이기
        - 중복 script 제거하기
        - 리다이렉트 피하기
            - 리다이렉트는 사용자를 한 URL에서 다른 URL로 다시 보내는 것을 말한다.
            - HTML 문서 모두 요청하기도 하며, 페이지 안에서 구성요소를 요청할 때도 사용된다.
        - 쿠키 사이즈 줄이기
        - iframe 갯수 줄이기
        - DOM 요소의 수를 줄이기 & DOM 접근을 최소화하기
        - Event Handler 잘 설정하기 ( 이벤트 위임을 통해 )